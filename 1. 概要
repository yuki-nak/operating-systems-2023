OSとは何か？
    Operating Systemの略でコンピュータ並びに周辺のハードウェアを操作、管理するためのソフトウェア。 狭義の意味ではカーネルそのものに当たり、広義の意味ではUbuntuなどコマンドインタプリタやGUI(Graphical User Interface)などユーティリティプログラムを含んだディストリビューションそのものを指す。


機械語とは何か？
    コンピュータに命令を与えるプログラムはC言語やPythonなど記述の抽象度が高い高級言語からいくつかの変換を経て中央演算装置（CPU）に読み込ませて実行される。その変換の最終形、つまりCPUが直接理解可能な0と1で構成される命令コードを機械語と呼ぶ。


なぜOSが必要か？
    OSが無かった場合、コンピュータのさまざまな資源を個別に管理する必要がある。例えば初期のコンピュータは1つのプログラムをメモリに載せて、プログラムの実行が終わるとまた次のプログラムをメモリに載せるということを繰り返していた。その後複数のプログラムを並行して動かしたいという要求から複数のプログラムをメモリに同時に配置する必要が出てきた。そのためプログラムごとの占有先の把握や、どの部分が未使用で、次にどの部分を割り当てるかといったメモリ管理が必要となった。このメモリ管理を可能とするのがOSである。もう一つ例を挙げると、メモリは通常揮発性のため電源を切ると保存していたデータは消える。従ってプログラムや計算に使用するデータは補助記憶装置に保存する。メモリ同様に補助記憶装置上の保存先の管理、人間がそれらデータをファイルシステムとして管理するためにはOSが必要になる。さらにOSがあることで補助記憶装置からプログラムをメモリにロードし、CPUで計算した結果をまた補助記憶装置に戻すといった作業もシームレスに実行できる。つまりハードウェア間を連結するためのインターフェースがOSの一つの役割である。

カーネルとは？
    プログラムの実行やメモリや入出力機器の割付けと保護や入出力操作、ファイル操作などのサービスを提供するコンピュータを管理する中核ソフトウェアのこと。前述のとおりOSとは狭義の意味でこのカーネルのことをさす。カーネルは通常メモリに常駐しており、システムコールの発行やデバイス割込みなどオンデマンドで使用することが多い。

カーネルの機能は？
    カーネルは一般的に以下の８種類の機能を有する。

    (1) プロセス管理
        OSで実行中のプログラムをプロセスまたはタスクと呼ぶ。プロセスやタスクはプロセッサが処理をするにあたり、生成や削除などいくつかの状態を持つ。これらの状態を把握し、管理することをプロセス管理と呼ぶ。

    (2) スケジューラ
        実際のプロセスの処理時間はとても短く、次々に入れ替わる。これはマルチタスク方式と呼ばれ、我々人間では複数の処理が同時に実行されるようにみえるが、このプロセスの割り付けを行う。

    (3) 同期と通信
        並列に動作する複数のプロセスがデータやプログラムなどの資源を共有する際に矛盾のないよう協調して処理を行う。この同期をおこなう。

    (4) メモリ管理
        メモリの空き領域を管理し、プログラムやデータを割り付ける際にメモリのどの番地に配置するかを決定する。

    (5) 割り込みと入出力制御
        割り込みは入出力機器の状態などをプロセッサに伝える仕組みである。割り込みは実行中のプログラムとは独立して発生するため割込専用のハードウェアが必要となる。

    (6) ファイルシステム
        ファイルとは、データの名前がつけられた集合である、データやプログラムを格納するための論理的な単位である。ファイルシステムはユーザが簡単にファイルを操作できるようにするためフォルダやディレクトリといった構造を使ってファイルを管理するための機構である。

    (7) ブートストラップ
        OSを起動するためには、電源を入れてブートストラップという手続きを取る。これは補助記憶装置内の特定の場所におかれたブートローダをメモリ上に移して起動する。ブートローダは保樹記憶装置内のカーネルをメモリに移し、カーネルを起動。起動後は制御をカーネルに移すという手続きを取る。

    (8) セキュリティ
        多くのOSではセキュリティ向上のためログイン時にユーザー名とパスワードを入力させる。また個々のファイルについても「読む」「書く」「実行する」といった単位でユーザごとに権限を与えアクセス制御する機能を備えている。


シェルとは？
    セキュリティの観点からユーザーはカーネルに直接命令したり操作することはできない。カーネルを操作するためにはインターフェースとなる専用のプログラムを使用する必要がある。そのプログラムをシェルと呼ぶ。狭義の意味ではUnixで使われるPOSIX Shellをシェルと呼ぶが、広義で言えばzsh, C Shell, Korn Shell, Bashなどそれぞれの特徴を備えたシェルが数多く開発されている。ちなみにBourne Shellという古いシェルが「sh」のコマンド名でかつて使われていたが、現在のPOSIX Shellでいう「sh」はBourne Shellとは異なるので注意が必要。

    参考: https://qiita.com/ko1nksm/items/6b61b0e687d206be9cb0

マイコンとマイクロプロセッサの違いは？
    マイコンはマイクロコントローラユニット（MCU）の略で演算に必要なCPUやメモリを1つのチップにまとめたものである。一方マイクロプロセッサユニット（MPU）もコンピュータの演算処理機能を実行するための小さな電子デバイスを指す。いずれも中央演算装置（CPU）を備えており、広い意味でCPUそのものとして使われている。このようにマイコンとマイクロプロセッサの明確な線引きはないが、一般的にマイコンというと演算ビット数が8〜32ビットで、動作周波数も数メガ〜数百メガヘルツといった消費電力、演算能力が低いチップを指す。

リアルタイムOSとは？
    自動車のブレーキ制御など定められた短い時間で処理を完了できるシステムをリアルタイムシステムと呼び、その処理時間を厳密に定義し実現するOSをリアルタイムOS（RTOS）と呼ぶ。またリアルタイム性でも定められた期限内に確実に完了を求める「ハードリアルタイム」と要求がそこまで厳しくない「ソフトリアルタイム」に大別される。リアルタイムOSの代表例として1980年代にTRONプロジェクトの一環として当時東京大学の助手だった坂村健氏を中心に開発されたITRONがある。ITRONを搭載した例としてトヨタ・ランドクルーザーやいわゆるガラケー、またNintendo Wii UやSwitchにはITRONの後継であるμITRONが搭載されている。なおリアルタイムOSの対義語としてUNIXなどのOSを「汎用OS」と呼ぶ。

OSノイズとは？
    OSノイズとは割り込みハンドラやプロセスの生成などOSカーネルや常駐するデーモンが担う処理にによって本来の計算性能の低下を招く要素を指す。高速なパフォーマンスを求める場合はこのOSノイズの低減も重要な要素となる。特に大容量のデータを補助記憶装置からメモリにロードする際は空きメモリの不足によりページングが発生するケースがよくある。

マルチプログラミングとは？
    前述したとおり現代のOSは複数のプログラム処理を高速に切り替えることであたかも並列に実行しているように見える。この方式をマルチプログラミング、または多重プログラミングと呼ぶ。

シミュレータとエミュレータの違いは？
    シミュレータとエミュレータはいずれも再現を行うシステムだがその定義の範囲が異なる。シミュレータはインターフェースの再現という表面上の再現に留まる。一方でエミュレータは更に厳密に中身の動作まで再現する。従ってゲーム機のコピーを作って遊ぼうと考えたらシミュレータでは不十分でエミュレータを開発する必要がある。

アプリケーションプログラムの生成方法は？
    普段目にする「xxxxx.exe」と呼ばれる実行ファイルはヘッダと複数のセクションから構成される。ヘッダはマジックナンバと呼ばれるファイル形式を識別するための数字（Windowsの実行ファイルの場合、先頭2バイトが0x4d 0x5a （MZ））から始まり、各セクションのサイズやプログラムの実行開始アドレス、サポートするOSのバージョンやプロセッサ情報などを格納している。代表的なセクションは以下のとおりである。

    (1) テキスト: プログラムの機械語命令部分 
    (2) データ: プログラムが使用するデータのうち、初期値が与えられているグローバル変数などを格納
    (3) BSS: 初期値が与えられていないデータのための領域。BSSとはblock started by symbolという1950年代のアセンブラの擬似命令に由来し、実行ファイルにはBSSセクションのサイズ情報のみが格納される。
    (4) 共有ライブラリ情報: 動的リンクする共有ライブラリに関する情報を格納
    (5) リロケーションテーブル: プログラムを任意のアドレスに配置するための情報を格納
    (6) シンボルテーブル: 関数やグローバル変数などシンボルとアドレスの対応表を格納する。また、動的リンクでは動的ライブラリからプログラムのアドレスを参照する際に用いる。デバッガはこの情報を使用することでアドレスではなくシンボル名を使用してデバッグができる。
    (7) デバッグ情報: 開発時のみに使用される情報で、ソースコードの行番号やアドレスの対応表などデバッグに必要な情報を格納。
    (8) その他: フォーマットによっては実行ファイルのアイコン画像などを格納可能

    ではこの実行ファイルはどのように生成されるのだろうか。基本的に以下の３つのステップを踏む。

    (1) コンパイル 
        C言語などの高級言語で書かれたプログラムをアセンブリ言語に変換することをコンパイルと呼び、それを行うプログラムをコンパイラと呼ぶ。アセンブリ言語とはCPUが直接解釈可能な機械語の命令（オペコード）と一対一に対応した言語で、プロセッサ（命令セットアーキテクチャ）ごと異なる仕様となる。機械語プログラムでは関数呼び出しやメモリへのアクセスなどあらゆる場面でメモリの番地指定を行うが、アセンブリ言語はアドレスの替わりにシンボル（ラベル）と呼ばれる識別子を使うことができる。そしてコンパイラは関数や静的変数の先頭アドレスに対して関数名や変数名のシンボルを生成する。

    (2) アセンブル
       コンパイラによってアセンブリ言語に変換されたプログラムは次にアセンブラによって機械語プログラムに変換され、オブジェクトファイルとして保存される。この一連の処理をアセンブルと呼ぶ。オブジェクトファイルの段階ではメモリアドレスは確定していないため、各セクションには0番地を仮の先頭アドレスとして機械語プログラムやデータを割り付け、シンボルのアドレスを計算する。一般的なプログラムはほかのオブジェクトファイルやライブラリで定義されている関数、グローバル変数など外部参照をおこなう。 例としてmain.cからライブラリ関数であるprintfを呼び出す場合、main.cから生成されたオブジェクトファイルの中でprintfの外部参照シンボルに対して仮のメモリアドレスを入れて、リンク時に正式なアドレスを割り付ける。オブジェクトファイルで定義や外部参照されたシンボルは仮アドレスとともにオブジェクトファイルのシンボルテーブルに格納する。また、絶対アドレスを使用しているオペランド（非演算子）や外部参照シンボルの値が確定して埋める箇所はオブジェクトファイルのリロケーションテーブルに格納する。


    (3) リンク
        オブジェクトファイル間を結合し、実行ファイルを生成するプログラムをリンカ（またはリンケージエディタ）と呼び、一連の処理をリンクと呼ぶ。リンカまたはリンクは静的と動的に分かれるが、通常リンクと言った場合は静的を指すことが一般的である。静的リンカは各オブジェクトに含まれる同一セクションを抜き出してプログラムの先頭アドレス　から順番に並べ、アドレスを割り付ける。この際に再配置（リロケーション）といってリロケーションテーブルを参照して各セクション中の配置アドレスに依存する箇所を修正する。また各オブジェクトファイルの中で定義されたシンボルのアドレスが確定するので外部参照シンボルを使用している箇所を確定したアドレスで埋めるシンボル解決をおこなう。これらの作業によって静的リンカはオブジェクトファイル中の外部参照シンボルを用いて静的ライブラリから必要なオブジェクトファイルを抜き出し実行ファイルに結合する。またランタイムライブラリという高水準言語で記述されたプログラムも併せて結合をおこない、最終的な実行ファイルを生成する。
       

コンピュータはどのように計算を可能にするか？
    コンピュータの根本動作は電圧を上げたり下げたりするだけです。その上げ下げを利用して照明のスイッチのようなオン・オフの状態を表現します。これをスイッチングと呼びます。コンピュータのスイッチングでは電圧が高いか低いか、しきい値を設けて状態は2つしかなく、中間は存在しません。よってアナログからデジタルに変換する場合、この中間に位置する0.5のような数値は全て1か0のいずれかに変換されます。

プロセッサの仕組みは？
    プロセッサはメインメモリから機械語を読み取り逐次実行する演算装置である。プロセッサはレジスタと呼ばれる高速で小容量のメモリを備えており、演算対象のデータやメモリアドレスをレジスタ内に保持する。これらレジスタの他にインストラクションポインタ（プログラムカウンタ）と呼ばれる特別なレジスタがあり、次に実行する機械語命令のアドレスを保持している。演算はプロセッサ内のALU（Arthimetic Logic Unit）がおこなう。また、コンピュータの動作調和を図るためクロック信号を送るクロックジェネレータを有している。これらモジュールを組み合わせることで演算とデータの読み書きをおこなう。

機械語命令はどのようなものがあるか？
    ADD, SUB, MUL, DIV: 四則演算
    MOV: レジスタやメモリの指定したアドレスとの間で値をコピー
    JMP: 指定したアドレスにジャンプ
    CALL: 指定したアドレスをサブルーチンとあいて呼び出す（関数呼び出しに相当）。CALL命令の次のアドレスをスタックにpushし、指定されたアドレスにジャンプする。
    RET: サブルーチンから呼び出し元に戻る。CALL命令でpushしたアドレスをスタックから pop し、そのアドレスにジャンプする。

    機械語命令を構成する中で命令部分をオペコード、命令を受けて操作されるアドレス（データ）をオペランドと呼ぶ。

    http://yuma.ohgami.jp/Introduction-to-x86_64-Machine-Language/a01_ml_inst_syntax_list.html


命令セットアーキテクチャの違いはどのような影響を生むか？
    プロセッサを制御するための命令語の体系を命令セットアーキテクチャと呼ぶ。現在市場で一般的なのはInelまたはAMDのx86系と呼ばれるものとARMアーキテクチャである。さらにx86系を64ビットに拡張した命令セットをx86_64と呼ぶ。　このx86とARMの対比はCISCとRISCの対比としても扱われる。CISCは（Complex Instruction Set Computer）の略称で、単一の命令で複数処理をおこなう設計の方向性である。例えば演算をおこなう際、メモリからレジスタに値をコピーし、演算をおこなう過程をCISCではメモリから値を読み込み、そのまま演算するような方式をとる。一方RISC（Reduced instruction Set Computer）は命令の複雑さを排除し、単純な命令を大量に処理することでパフォーマンスを上げようとする設計思想である。

スタックポインタとスタックフレームの違いは？
    CPUにおけるスタックとはレジスタの一部で、割り込み発生時にプログラムのフラグやプログラムカウンタの値を一時的に保存する場所である。スタックポインタとはスタック管理のポインタであり退避先のメモリ番地（メモリスタック領域の最上部。コールスタックとも呼ぶ）を示す。以下はメインルーチンからサブルーチンを呼び、復帰するまでの流れである。

        1. メインルーチンの次に実行される命令アドレスをスタックに格納
        2. サブルーチンのアドレスをプログラムカウンタに設定
        3. サブルーチン用の局所変数領域をスタックの最上段に作成
        4. サブルーチンを実行
        5. サブルーチン用の局所変数領域を開放
        6. スタック最上段に格納された復帰先をプログラムカウンタに設定
        
        *応用情報技術者平成28年秋期問題解説より

    一方スタックフレームとはサブルーチンを呼び出した際にCPUからコールスタックに積まれた情報のまとまりを指す。コールスタックにスタックフレームを格納することをワインドと呼び、サブルーチンから抜けてコールスタックから情報を戻すことをアンワインドと呼ぶ。


カーネルモードとユーザーモードの違いは？
    カーネルモードとユーザーモードはプロセッサが指定した動作モードである。カーネルモードはOSカーネルを実行するためのモードでありプロセッサのすべての動作を制限なくおこなえる。一方ユーザーモードは特権命令と呼ばれるシステムに悪影響を与える可能性のある一部の機械語命令が使用できない。またハードウェアへの直接的なアクセスも禁止されている。


マルチコアプロセッサシステムとは？
    マルチコアのはじまりは1999年IBMにより開発されたPOWER 4の時代まで遡る。それまでプロセッサのパフォーマンスはいかにクロック数を上げ、プロセッサの処理速度を速くするか、であったがマルチコアの登場により、並列処理が可能となった。現代ではマルチコア搭載が一般的となっている。マルチコアのメリットはクロック数を上げずに計算処理を早めることであるが、デメリットとしては複雑さが挙げられる。並列処理をおこなうには処理の重複がおこらないよう排他制御を考え実装する必要がある。

メモリとは？
    データの保存を担う装置を記憶装置と呼びます。
    最も小さい記憶装置はCPUの一部であるレジスタになりますが、レジスタを集積したものがメモリ (RAM)です。RAMはRandom Access Memoryの略で、無作為に選ばれたワードに対して、そのワードの位置に関わらず同じ時間でアクセスできることを意味します。またメモリ以外にも補助記憶装置としてハードディスクやSSDが使用されます。これら補助記憶装置は電源をオフにしてもデータが残る非揮発性であることが一般的です。

キャッシュメモリとは？
キャッシュメモリとはCPUとメインメモリの間にある記憶装置でアクセス頻度の高いデータや命令を一時的に保存できる場所。キャッシュメモリはCPUからの距離（処理速度）に応じてL1、L2など階層化構造を取っている。これらはレジスタと同じような働きをするが、レジスタは演算処理そのものを実行することを目的とする一方、キャッシュメモリはデータ取得の効率化を目的としている。キャッシュメモリはレジスタと比べアクセスに時間が掛かるが、大容量データが保存可能である。またメインメモリで使われるDRAMと比べキャッシュメモリで使用されるSRAMはDRAMより単価が高いが、リフレッシュ動作が不要のため高速で低消費電力というメリットがある。

ハードウェアクロックとは？
    我々が使用しているパソコンはシステムクロックとハードウェアクロックという２つの時計を持っている。システムクロックはOSが管理している時計でNTPなどで得た時刻を参照している。しかしOSで管理しているため一度電源を落とすとその情報は失われる。そのためPC本体の起動などシステムクロックが対応できない時間に参照されるのがハードウェアクロックである。ハードウェアクロックの精度は決して高くはないため定期的にシステムクロックの時間を参照し、同期を図る。またマザーボード上にある専用電池によって駆動するため、電池切れになるとOS起動時の時刻が合わないなどといった事象が発生する。

OSの起動はどのように行われるか？
    前述のとおりOSを起動するには補助記憶装置にあるカーネルをメモリにロードする。OSを使用せずにこの動作をおこなうためにコンピュータではROMやフラッシュメモリなど不揮発性メモリ上にブートストラップローダというプログラムを格納している。
    
     (1) 電源を入れるとパワーオンリセットと呼ばれる回路にとりプロセッサがリセットされる。これによりプロセッサは初期状態となり、特定の物理アドレスから実行を開始する。このアドレスにはBIOSの実行開始アドレスにジャンプする機械語命令が入っている。

     (2) BIOSは最初にPOST(power on self test)と呼ばれる簡単なハードウェア診断処理をおこない、物理メモリの容量確認や起動に必要な周辺機器の検出や初期化などをする。

     (3) OSが保存されている補助記憶装置であるブートデバイスの先頭にあるMBR(master boot record)と呼ばれる領域を読み込む。MBRにはブートストラップコードと呼ばれる小さい機械語プログラムと補助記憶装置を論理的に分割したパーテーション情報が含まれている。MBRを読み込んだあと、ブートストラップコードに制御を移す。
     * UEFIではMBRでなくGPT（GUID partition table）と呼ばれるブートストラップコードがない、BIOSが直接パーティション情報を解釈する形式パーテーション情報をサポートしている。
     　OSごとにカーネルが保存されている補助記憶装置ファイルシステムは異なるなるが、UEFIはそれぞれのファイルシステムを解釈し、セカンダリブートローダを使わずに直接カーネルをロードすることも可能である。

     (4) ブートストラップコードはパーティション情報をチェックしブート可能とマークされているパーティションの先頭からセカンダリブートローダと呼ばれる小さなプログラムをロードし実行する。
     
     (5) セカンダリブートローダはOSを使わずに直接補助記憶装置にアクセスし、カーネルを読み込む。

     (6) 読み込んだカーネルの実行開始アドレスにジャンプし、カーネルの軌道処理を開始させる。
