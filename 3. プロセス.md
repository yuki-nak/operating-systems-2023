プロセスとスレッドの違いは何か？
    OSで実行中の命令プログラムをプロセスと呼びます。プロセスはOSを実行するにあたり以下の単位として用いられます。

    保護の単位
    プロセス単位でデータのアクセス権を分けることができます。そのため不備のあるプログラムを動かす場合でその他のプロセスやOSに影響を与えず、問題があった場合もシステム全体に影響を及ぼさないで済みます。

    資源割当ての単位
    プログラムの実行には機械語を実行するプロセッサとプログラムやデータを配置するメモリが必要です。

    権限の単位
    OS上にはファイルや、各種デバイス、プロセス間通信で用いるソケットや共有メモリなどさまざまなオブジェクトが存在します。OSはそれぞれのオブジェクトに対して操作を行う権限をプロセスごとに管理します。

    一方スレッドとはプロセス内の実行単位で処理実行における抽象概念です。プロセスは最低１つのスレッドを持ちます。これをシングルスレッドと呼びます。複数のスレッドを持つプロセスはマルチスレッドと呼びます。
    スレッドはローカル変数の格納場所である専用のスタック、プロセッサ状態、オブジェクトコードの現在位置(通常はプロセッサの命令ポインタ)をそれぞれ独自に持ちます。逆に言うと、プロセスのそれ以外の要素は全て他のスレッドと共有します。

プロセスの生成方法は？
    Unixでプロセスを生成する場合は通常fork()システムコールを使用し、親プロセスを複製し、独自のプロセスIDを与える。次にexec()システムコールで実行中のプログラムをシステムコールの引数で指定した実行ファイルに入れ替える。

    一方Windowsにfork/exec方式はなく、替わりにspawn方式でプロセスを生成する。これはシステムコールの引数で実行ファイルを指定し、プロセスの生成と実行を同時におこなう方式である。

プロセスのライフサイクルは？

    created: プロセスが生成された状態
    running: プロセッサが割り当てられ実行している状態
    runnable: 実行可能だがプロセッサが割り当てられていない状態
    blocked: 何らかのイベントを待っているためプロセッサが割り当てられない状態
    terminated: プログラムの実行が終わるか明示的に終了されられる状態。

マルチスレッドプロセッシングの実現方法は？
    1つのプロセスで複数のスレッドを動作させる方法はいくつかあるが、一般的に、それぞれのユーザスレッドに対しカーネルが管理するスレッド（カーネルスレッド、またはLWP(light weight process)）を対応させる1対1モデルを採用している。この方式ではすべてのスレッドは同時にシステムコールの発行が可能である。スレッドの生成はLinuxのcloneなどシステムコールを使用する。スレッドが生成されるとカーネルはここのスレッドに対してスレッド制御ブロック（thread control block; TCB）と呼ばれるデータ構造を割り当てる。TCBには以下の情報が含まれる。

        - スレッドID
        - スレッドが所属するプロセスへのPCB（process control block）ポインタ
        - スレッドはローカル変数の格納場所である専用のスタック、プロセッサ状態、オブジェクトコ
        - スレッドの状態
        - 実行中のプロセッサの番号（マルチプロセッサシステムのみ）
        - 優先度などスケジューリングに必要な情報
        - スレッドが使用するカーネルスタック (スレッドごとに必要)

システムコールの実行ステップは？
    1. システムコールのラッパー関数の呼び出し
    2. システムコール番号とシステムコールへの引数をレジスタやスタックなどに書き込む
    3. ラッパー関数が特別な機械語命令であるシステムコール命令を実行。ここでカーネルモードに切り替える
        (1) プロセッサをカーネルモードに遷移
        (2) スタックをカーネルスタックに切り替え
        (3) プログラムカウンタの値やカーネルスタックに切り替える前のスタックポインタの値などをレジスタやカーネルスタックに退避
        (4) カーネル内にあるシステムコールを処理するためのルーチン（システムコールルーチン）に制御を移す
    4. システムコール処理ルーチーンはシステムコール番号を読み取り、システムコール処理関数を呼び出す
    5. システムコール処理ルーチンに制御が戻る。ここでシステムコールのm帰り値をレジスタなどに書き込み、ユーザモードに戻るための機械語命令を実行
    6. ユーザモードに戻り、退避した情報を復元。プログラムカウンタはシステムコール命令直後のアドレスに設定され、そこから実行を再開。
    7. ラッパー関数はカーネルからの返り値を受け取り、ラッパー関数の返り値として返す。


スケジューリングの種類はどのようなものがあるか？
    代表的なスケジューリングアルゴリズムを以下に示す。

    (1) 到着順スケジューリング (first come, first served scheduling; FCFS)
        バッチ処理のためのスケジューリングアルゴリズムで、プロセスはシステムに到着した順に処理される。プリエンプションは行わない。

    (2) 最短ジョブ優先スケジューリング (shortest job first scheduling; SJF)
        こちらもバッチ処理のためのアルゴリズムで、レディキュー内のプロセスの中で次のCPUバーストがもっとも短いプロセスを実行する。プリエンプションは行わない。

    (3)　ラウンドロビンスケジューリング (round robin scheduling; RR)
        FCFSにプリエンプションを取り入れたもの。タイムシェアリングシステムで使用された。プロセスはFCFSと同じ順序でキューに追加されるが、実行を開始したプロセスはタイムスライス時間が経過するとプリエンプションされ、キューの最後に追加される。FCFSより公平性は担保される一方でCPUバウンドなプロセスよりもI/Oバウンドなプロセスの方がプロセッサの割り当て時間が短くなる。

    (4) 優先度順スケジューリング (priority scheduling)
        各プロセスが持つ優先度が最も高いプロセスにプロセッサを割り当てる方式。バッチ処理、対話方システムの両方で使われる。優先度には一定範囲の整数値が使用される。同一優先度に複数プロセスが存在する場合はそれらの中でFCFSやRRが行われる。

    (5) 多段フィードバックスケジューリング (multilevel feedback queue scheduling)
        プロセスが消費したプロセッサ時間などにもとづいて優先度が変化する。実行開始直後のプロセスには優先してプロセッサが割り当てられるが、プロセスの実行時間が長くなるにつれて優先度が次第に下がり、他のこう優先度プロセスが優先される。またプロセッサをあまり使用しない対話的プロセスやI/Oバウンドなプロセスの優先度は下がりにくい。優先度が低いキューにあるプロセスは飢餓状態になるため対策としてエイジングが用いられる。

    (6) フェアシェアスケジューリング
        プロセス単位でなく、ユーザやグループ単位でプロセッサ時間を配分するアルゴリズム。まず各ユーザやグループに対してプロセッサ時間を均等に分配し、さらに各自が所有するプロセスに均等に分配する。Linuxではバージョン2.6.23からフェアシェアスケジューリングを採用している。

マルチプロセッサのスケジューリングはどのようにして行われるか？
    マルチプロセッサでは複数スレッドを同時に並列実行可能だが、スケジューラはそれらスレッドをどのタイミングで走らせるかを決めなければないらない。簡単な方法としてスケジュリーリングのためのデータ構造（レディキュー）をカーネルに1つだけ保持し、すべてのプロセッサで共有する方法がある。（ただしプロセッサ間の違いが考慮されていない。）


コンテキストスイッチとは？
    コンテキストスイッチはスタックとレジスタの切り替えである。コンテキストスイッチはシステムコールによって発生する自発的なケースと、プリエンプションによって発生する非自発的な２種類に分かれる。いずれの場合もコンテキストスイッチはカーネル内で発生する。



セマフォはどのようにして実現されるか？
    セマフォはエドガー・ダイクストラにより考案されたスレッド間が共有する資源のアクセスを制御するための変数または抽象データ型である。セマフォは利用可能な資源の数を表す整数と、資源利用を待っているスレッドを並べておくための待機キューから構成されている。

    wait
    セマフォの値を−1する。値が負の整数になったらwaitを実行したスレッドをキューに追加しブロックする。値が0以上ならばブロックせずに終了する。

    signal
    セマフォの値を+1する。増やす前の値が負の整数ならば待機キューからwait中のスレッドを1つ取り出しスレッドを起動する。増やす前の値が0以上ならば特に何もしない。

    このwaitとsignalの処理は切り離さずに一対の処理として実行される。

    一方でセマフォにも欠点がある。
        - 排他制御にも同期にも使用できるためプログラムコードをみても用途が把握しづらい。
        - 複数のセマフォを使うとwaitとsignalが一対とならないためプログラムのバグを生みやすい。
        - 所有権の概念がないため再帰的ロック（ロックを保持しているスレッドがロックを保持したまま再度ロックを獲得すること）ができない。
        - プリエンプションされても優先度の高いスレッドに移譲できない。

Mutexとは？
    排他制御の機構の1つで、Lockとunlockがあり、それぞれENTERとLEAVEに対応する。mutexはセマフォに似ているが、排他制御に特化した機構で、ロックに成功したスレッドだけがアンロックを実行できる。同期に関しては条件変数を併用することで実現する。
モニタとは？
    セマフォやmutexは排他制御を忘れたり、ロックの獲得と解除がマッチしないなどバグが生じやすい。このためプログラミング言語自体に排他制御を扱うための構文を設ける「モニタ」という手法が提案された。
    モニタでは排他制御すべきデータは別で定義し、同じモニタの中で定義された関数のみが扱うことができる。モニタ内の関数は違いに排他制御される。

IPCの実現方法は？
    プロセス間通信（Interprocess communications）はOSの以下の機構を使い実現する。

    パイプ
    同一コンピュータ上の２つのプロセス間でやりとりする仕組み。1つのパイプには送信側と受信側の2つの端点であるエンドポイントがあり、片方のプロセスに送信側、もう片方のプロセスに受信側の端点を割り当てることでデータのやりとりをおこなう。これはOSのシステムコールにより、OSに書き込まれたデータをカーネル内のメモリに一時的に保存（バッファリング）ことで実現する。

    メッセージキュー
    プロセス間でメッセージをやり取りするための仕組み。Windowsのアプリケーションプログラムはウインドウの移動やクローズ、マウスクリックなどのイベントをメッセージキューを通じて受け取り処理している。

    共有メモリ
    複数のプロセスがメモリの一部を共有するためデータコピーの必要がなく速い。プロセスから共有メモリを読み書きする処理は通常危険領域となるのでセマフォやmutexなどの排他制御機構とペアで使用する。

    ソケット
    同一のコンピュータだけでなく、TCP/IPなどのネットワーク通信も含むさまざま用途で使用できるAPI。多くの言語処理系で実装されている。